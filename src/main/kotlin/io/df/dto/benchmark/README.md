# DTO 변환 벤치마크 개요

## 실행 흐름
- `DtoConversionBenchmark`는 `ApplicationRunner`로 등록되어 애플리케이션 기동 시 자동 실행됩니다.
- `generateEntities`가 약 1,000개의 가짜 `SampleEntity`를 생성해 실제 업무 시나리오와 유사한 데이터를 준비합니다.
- `warmUp`을 통해 변환 작업을 두 번 미리 수행하여 JVM JIT 최적화가 일어난 뒤 본 측정을 진행합니다.

## 성능 측정 방식
- 변환 루프에서 엔티티마다 `System.nanoTime()`으로 변환 전/후 시간을 측정하고 `LongSummaryStatistics`에 누적합니다.
- 전체 변환 시간 외에도, 모든 DTO 리스트가 만들어지기까지 걸린 총 소요 시간을 별도로 계산해 로그로 남깁니다.
- 결과 로그에는 총 개수, 총합, 평균, 최소, 최대 변환 시간이 밀리초(ms) 단위로 표시되고, DTO 한 건 샘플은 `DEBUG` 로그로 확인할 수 있습니다.

## 변환 로직 특징
- 태그 목록은 소문자 변환 후 정렬하여 `tagSummary`에 저장합니다.
- 메타데이터는 키 기준으로 정렬하고 값 일부를 잘라 `key:value` 문자열을 이어 붙여 `metadataDigest`를 만듭니다.
- 점수는 50점 단위 구간으로 버킷화하여 범위 문자열(`e.g., "0-50"`)로 변환합니다.
- 생성일시는 UTC epoch milli로 변환해 DTO에 담습니다.

## 확장/활용 포인트
- `ENTITY_COUNT`, `WARM_UP_ITERATIONS` 등 상수를 조절해 데이터 규모나 반복 횟수를 쉽게 바꿀 수 있습니다.
- `SampleEntity`와 `SampleDto`를 실제 도메인 모델로 교체하면 현업 코드 기반의 변환 비용을 직접 측정할 수 있습니다.
- `./gradlew bootRun`으로 실행 후 콘솔 로그를 통해 DTO 캐싱 방식과의 성능 차이를 정량적으로 비교하세요.


# JIT 예열 이유
네 🙂 조금 더 쉽게 풀어서 설명해드릴게요.

```kotlin
// 1) 워밍업: 캐시 없이
repeat(warmup) {
    data.forEach { mapper(it) }
}
```

---

## 이 코드가 하는 일

* `data` 안에 있는 모든 엔티티를 `mapper` 함수로 DTO로 바꿔봅니다.
* `repeat(warmup)` 만큼 여러 번 반복합니다. (보통 1\~3회 정도)
* 결과는 어딘가에 저장하지 않고 그냥 버려요.

즉, "실제 측정 전에 미리 여러 번 돌려서 몸을 풀기" 같은 겁니다.

---

## 왜 이런 "워밍업"을 할까?

1. **JVM이 처음에는 느리게 실행하기 때문**

    * 자바/Kotlin 프로그램은 처음엔 *인터프리터*로 실행하다가, 자주 쓰이는 코드가 반복되면 JIT(Just-In-Time) 컴파일러가 알아서 더 빠른 기계어 코드로 바꿉니다.
    * 그래서 프로그램을 막 시작하자마자 시간을 재면 "아직 최적화 전"이라 실제보다 느리게 나올 수 있어요.

2. **CPU와 메모리도 예열됨**

    * CPU 캐시, 메모리 할당, 문자열 처리 같은 것들도 몇 번 반복하다 보면 점점 빨라집니다.
    * 마치 차 시동 걸고 엔진을 조금 데워야 제 성능이 나오는 것처럼요.

3. **캐시 없는 상태로만 돌리는 이유**

    * 우리가 측정하려는 건 "순수 변환(Entity → DTO) 비용"입니다.
    * 만약 여기서 캐시를 쓰면 일부는 빠르게 끝나버려서 실제 변환 비용이 제대로 측정되지 않습니다.

---

## 비유로 설명

* 마라톤에서 기록 재기 전에 **몸풀기 스트레칭**을 하는 것과 비슷합니다.
* 바로 달리면 첫 1km는 몸이 굳어서 늦게 나오지만, 몸을 풀고 나면 진짜 속도가 나오죠.
* 이 워밍업 루프가 바로 그 “스트레칭” 역할이에요.

---

👉 정리하면, 이 코드는 \*\*“측정 전에 JIT과 CPU가 최적화되도록 일부러 여러 번 실행하는 단계”\*\*입니다.
그래서 결과는 안 쓰고, 그냥 돌려주기만 해도 충분해요.

---

혹시 원하시면 제가 이 워밍업 단계를 **“있을 때 vs 없을 때” 속도 차이**를 눈에 보이게 출력하는 간단한 실험 코드도 만들어드릴까요?
