

# 📘 5장 5.1 섣부른 최적화가 나쁠 때

## 5.1 핵심 내용

* 성능 최적화는 항상 좋은 것이 아님.
* **문제점**:

    * 예상되는 트래픽, 입력 데이터, SLA 정보 없이 최적화를 시도 → 잘못된 가정 기반 → 복잡성 증가, 유지보수성 저하.
    * 실제로 병렬화(parallelStream 등) 같은 “최적화”가 더 느릴 수도 있음.
* 따라서 \*\*“충분한 데이터 없이 한 최적화는 낭비”\*\*라는 교훈.

---

## 5.1.1 계정 처리 파이프라인 생성

* 단순한 계정 엔티티(Account)를 대상으로 ID를 찾는 로직.
* **Stream API 사용 예제**:

  ```java
  return accounts.stream()
      .filter(v -> v.getId().equals(id))
      .findAny();
  ```
* `findAny()` vs `findFirst()`

    * `findAny()`: 순서 보장 없음 → 병렬 스트림에서 성능 우위.
    * `findFirst()`: 순서를 보장 → 직렬적 성격 → 병렬 처리 시 성능 저하 가능.

👉 **교훈**: 병렬화/최적화 기법 선택 시 데이터 크기와 처리 패턴을 고려해야 한다.

---

## 5.1.2 잘못된 가정에 기반한 최적화

* 잘못된 가정: "항목이 수천 개 이상이므로 병렬 처리하면 빠를 것이다"
* 실제로는:

    * **작업 훔치기(work-stealing)** 알고리즘 사용 시, 작업 분할/스레드 관리 비용이 추가됨.
    * 데이터가 적으면 오히려 병렬이 직렬보다 느림.
* 따라서, “병렬 처리 = 무조건 빠름”이라는 **잘못된 가정은 위험**.

---

## 5.1.3 성능 최적화 벤치마크

* 최적화 효과 검증을 위해 **벤치마크 필수**.
* Java에서는 JMH(Java Microbenchmark Harness), .NET에서는 BenchmarkDotNet 사용.
* **벤치마크 결과**:

    * 일반 Stream vs parallelStream → 작은 데이터셋에서는 큰 차이 없음.
    * 병렬 처리가 분할/스레드 관리 오버헤드 때문에 느릴 수도 있음.
    * 데이터가 충분히 커지면 parallelStream이 유리해짐.

👉 **교훈**: “추측이 아닌 데이터 기반 성능 측정”을 통해 최적화 여부를 판단해야 함.

---

## 요약 압축

* **섣부른 최적화는 해로움**: 데이터 없는 상태에서 성능 개선 시도 → 복잡성만 증가.
* **잘못된 가정은 위험**: 병렬화가 항상 빠른 것은 아님.
* **벤치마크로 검증**: 실제 트래픽/데이터 기반 성능 측정으로 최적화 여부 판단.

---

## 💡 제 생각 (챕터별 첨언)

* **5.1**: 개발자가 흔히 빠지는 함정. 특히 스타트업 환경에서는 "미리 최적화해야 한다"는 강박이 많음. 사실상 대부분은 “읽기 쉬운 코드”가 더 큰 가치.
* **5.1.1**: `findAny()` vs `findFirst()` 같은 작은 차이가 대규모 서비스에서는 큰 성능 차이를 만들 수 있음. 하지만 초기엔 단순성을 우선하는 게 맞음.
* **5.1.2**: 병렬화는 CPU 코어 수, 데이터 크기, 상태 공유 여부에 따라 효과가 다름. 추측은 금물.
* **5.1.3**: 벤치마크 자동화를 CI/CD에 넣어두면 실서비스 환경 변화에도 성능 회귀를 빠르게 탐지할 수 있음.

---

# 🧑‍💻 Kotlin 예제 코드 (도메인: 계정 탐색)

### As-Is (섣부른 최적화 없음)

```kotlin
data class Account(val id: Int, val name: String)

class AccountFinder(private val accounts: List<Account>) {
    // 단순한 탐색 로직 (Stream API에 해당)
    fun findAccount(id: Int): Account? {
        return accounts.firstOrNull { it.id == id } // 순차 탐색
    }
}
```

### To-Be (병렬 최적화 적용, 하지만 복잡성 증가)

```kotlin
class AccountFinderOptimized(private val accounts: List<Account>) {
    // 잘못된 가정 기반: 병렬 처리하면 항상 빠를 것이다?
    fun findAccountParallel(id: Int): Account? {
        return accounts.parallelStream()
            .filter { it.id == id }
            .findAny()
            .orElse(null)
    }
}
```

---

# ✅ Kotest 테스트 코드

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
import kotlin.system.measureTimeMillis

class AccountFinderTest : StringSpec({

    val accounts = (0 until 10_000).map { Account(it, "User$it") }

    "As-Is 방식 테스트" {
        val finder = AccountFinder(accounts)
        val time = measureTimeMillis {
            finder.findAccount(9999)?.id shouldBe 9999
        }
        println("As-Is 방식 실행 시간: ${time}ms")
    }

    "To-Be 병렬 방식 테스트" {
        val finder = AccountFinderOptimized(accounts)
        val time = measureTimeMillis {
            finder.findAccountParallel(9999)?.id shouldBe 9999
        }
        println("To-Be 병렬 방식 실행 시간: ${time}ms")
    }
})
```

👉 실제로는 작은 데이터셋에서는 차이가 거의 없고, 병렬 오버헤드 때문에 더 느릴 수 있음.

---

# 📊 참고 표 (책 내용을 재구성)

| 방식         | 장점                 | 단점                    |
| ---------- | ------------------ | --------------------- |
| 단순 순차 탐색   | 코드 단순, 유지보수 용이     | 대규모 데이터에서는 느릴 수 있음    |
| 병렬 스트림     | 대규모 데이터에서 성능 향상 가능 | 스레드 관리/작업 분할 오버헤드 발생  |
| 잘못된 가정 최적화 | 이론적으로는 빠를 수도 있음    | 실제로는 데이터 크기 작으면 성능 저하 |

---

# 🔗 참고 자료 (외부)

* [JMH(Java Microbenchmark Harness)](https://openjdk.org/projects/code-tools/jmh/)
* [BenchmarkDotNet(.NET 벤치마크 프레임워크)](https://benchmarkdotnet.org/)
* [Java Stream vs ParallelStream 성능 분석 글](https://www.baeldung.com/java-when-to-use-parallel-stream)

